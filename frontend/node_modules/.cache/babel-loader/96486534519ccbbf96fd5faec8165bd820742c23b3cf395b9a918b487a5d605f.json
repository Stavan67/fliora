{"ast":null,"code":"class WebRTCService {\n  constructor() {\n    this.peerConnections = new Map();\n    this.localStream = null;\n    this.stompClient = null;\n    this.roomCode = null;\n    this.currentUserId = null;\n    this.onRemoteStream = null;\n    this.onParticipantLeft = null;\n    this.configuration = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }]\n    };\n  }\n  initialize(stompClient, roomCode, userId, localStream) {\n    this.stompClient = stompClient;\n    this.roomCode = roomCode;\n    this.currentUserId = userId;\n    this.localStream = localStream;\n\n    // Subscribe to WebRTC signaling messages\n    this.stompClient.subscribe(`/topic/signal/${roomCode}`, message => {\n      this.handleSignalingMessage(JSON.parse(message.body));\n    });\n  }\n  async createPeerConnection(participantId) {\n    if (this.peerConnections.has(participantId)) {\n      return this.peerConnections.get(participantId);\n    }\n    const peerConnection = new RTCPeerConnection(this.configuration);\n    this.peerConnections.set(participantId, peerConnection);\n\n    // Add local stream tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        peerConnection.addTrack(track, this.localStream);\n      });\n    }\n\n    // Handle incoming stream\n    peerConnection.ontrack = event => {\n      console.log('Received remote track from:', participantId);\n      if (this.onRemoteStream) {\n        this.onRemoteStream(participantId, event.streams[0]);\n      }\n    };\n\n    // Handle ICE candidates\n    peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        this.sendSignalingMessage({\n          type: 'ice-candidate',\n          candidate: event.candidate,\n          from: this.currentUserId,\n          to: participantId\n        });\n      }\n    };\n\n    // Handle connection state changes\n    peerConnection.onconnectionstatechange = () => {\n      console.log(`Connection state with ${participantId}:`, peerConnection.connectionState);\n      if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {\n        this.closePeerConnection(participantId);\n      }\n    };\n    return peerConnection;\n  }\n  async createOffer(participantId) {\n    const peerConnection = await this.createPeerConnection(participantId);\n    const offer = await peerConnection.createOffer();\n    await peerConnection.setLocalDescription(offer);\n    this.sendSignalingMessage({\n      type: 'offer',\n      offer: offer,\n      from: this.currentUserId,\n      to: participantId\n    });\n  }\n  async handleSignalingMessage(message) {\n    const {\n      type,\n      from,\n      to,\n      offer,\n      answer,\n      candidate\n    } = message;\n\n    // Ignore messages not meant for us\n    if (to && to !== this.currentUserId) {\n      return;\n    }\n\n    // Don't process our own messages\n    if (from === this.currentUserId) {\n      return;\n    }\n    try {\n      switch (type) {\n        case 'offer':\n          await this.handleOffer(from, offer);\n          break;\n        case 'answer':\n          await this.handleAnswer(from, answer);\n          break;\n        case 'ice-candidate':\n          await this.handleIceCandidate(from, candidate);\n          break;\n        case 'participant-left':\n          this.handleParticipantLeft(from);\n          break;\n        default:\n          console.log('Unknown signaling message type:', type);\n      }\n    } catch (error) {\n      console.error('Error handling signaling message:', error);\n    }\n  }\n  async handleOffer(participantId, offer) {\n    const peerConnection = await this.createPeerConnection(participantId);\n    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n    const answer = await peerConnection.createAnswer();\n    await peerConnection.setLocalDescription(answer);\n    this.sendSignalingMessage({\n      type: 'answer',\n      answer: answer,\n      from: this.currentUserId,\n      to: participantId\n    });\n  }\n  async handleAnswer(participantId, answer) {\n    const peerConnection = this.peerConnections.get(participantId);\n    if (peerConnection) {\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n    }\n  }\n  async handleIceCandidate(participantId, candidate) {\n    const peerConnection = this.peerConnections.get(participantId);\n    if (peerConnection) {\n      await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n    }\n  }\n  handleParticipantLeft(participantId) {\n    this.closePeerConnection(participantId);\n    if (this.onParticipantLeft) {\n      this.onParticipantLeft(participantId);\n    }\n  }\n  sendSignalingMessage(message) {\n    if (this.stompClient && this.stompClient.connected) {\n      this.stompClient.publish({\n        destination: `/app/signal/${this.roomCode}`,\n        body: JSON.stringify(message)\n      });\n    }\n  }\n  notifyJoin() {\n    this.sendSignalingMessage({\n      type: 'join',\n      from: this.currentUserId\n    });\n  }\n  notifyLeave() {\n    this.sendSignalingMessage({\n      type: 'participant-left',\n      from: this.currentUserId\n    });\n  }\n  updateLocalStream(newStream) {\n    this.localStream = newStream;\n\n    // Update all peer connections with new tracks\n    this.peerConnections.forEach((peerConnection, participantId) => {\n      const senders = peerConnection.getSenders();\n      const newTracks = newStream.getTracks();\n      senders.forEach(sender => {\n        const newTrack = newTracks.find(track => {\n          var _sender$track;\n          return track.kind === ((_sender$track = sender.track) === null || _sender$track === void 0 ? void 0 : _sender$track.kind);\n        });\n        if (newTrack) {\n          sender.replaceTrack(newTrack);\n        }\n      });\n    });\n  }\n  toggleTrack(kind, enabled) {\n    if (this.localStream) {\n      const tracks = kind === 'video' ? this.localStream.getVideoTracks() : this.localStream.getAudioTracks();\n      tracks.forEach(track => {\n        track.enabled = enabled;\n      });\n    }\n  }\n  closePeerConnection(participantId) {\n    const peerConnection = this.peerConnections.get(participantId);\n    if (peerConnection) {\n      peerConnection.close();\n      this.peerConnections.delete(participantId);\n    }\n  }\n  cleanup() {\n    this.notifyLeave();\n    this.peerConnections.forEach((pc, id) => {\n      pc.close();\n    });\n    this.peerConnections.clear();\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n    this.stompClient = null;\n    this.roomCode = null;\n    this.currentUserId = null;\n  }\n}\nexport default new WebRTCService();","map":{"version":3,"names":["WebRTCService","constructor","peerConnections","Map","localStream","stompClient","roomCode","currentUserId","onRemoteStream","onParticipantLeft","configuration","iceServers","urls","initialize","userId","subscribe","message","handleSignalingMessage","JSON","parse","body","createPeerConnection","participantId","has","get","peerConnection","RTCPeerConnection","set","getTracks","forEach","track","addTrack","ontrack","event","console","log","streams","onicecandidate","candidate","sendSignalingMessage","type","from","to","onconnectionstatechange","connectionState","closePeerConnection","createOffer","offer","setLocalDescription","answer","handleOffer","handleAnswer","handleIceCandidate","handleParticipantLeft","error","setRemoteDescription","RTCSessionDescription","createAnswer","addIceCandidate","RTCIceCandidate","connected","publish","destination","stringify","notifyJoin","notifyLeave","updateLocalStream","newStream","senders","getSenders","newTracks","sender","newTrack","find","_sender$track","kind","replaceTrack","toggleTrack","enabled","tracks","getVideoTracks","getAudioTracks","close","delete","cleanup","pc","id","clear","stop"],"sources":["E:/fliora/fliora/frontend/src/services/WebRTCService.js"],"sourcesContent":["class WebRTCService {\r\n    constructor() {\r\n        this.peerConnections = new Map();\r\n        this.localStream = null;\r\n        this.stompClient = null;\r\n        this.roomCode = null;\r\n        this.currentUserId = null;\r\n        this.onRemoteStream = null;\r\n        this.onParticipantLeft = null;\r\n\r\n        this.configuration = {\r\n            iceServers: [\r\n                { urls: 'stun:stun.l.google.com:19302' },\r\n                { urls: 'stun:stun1.l.google.com:19302' },\r\n                { urls: 'stun:stun2.l.google.com:19302' }\r\n            ]\r\n        };\r\n    }\r\n\r\n    initialize(stompClient, roomCode, userId, localStream) {\r\n        this.stompClient = stompClient;\r\n        this.roomCode = roomCode;\r\n        this.currentUserId = userId;\r\n        this.localStream = localStream;\r\n\r\n        // Subscribe to WebRTC signaling messages\r\n        this.stompClient.subscribe(`/topic/signal/${roomCode}`, (message) => {\r\n            this.handleSignalingMessage(JSON.parse(message.body));\r\n        });\r\n    }\r\n\r\n    async createPeerConnection(participantId) {\r\n        if (this.peerConnections.has(participantId)) {\r\n            return this.peerConnections.get(participantId);\r\n        }\r\n\r\n        const peerConnection = new RTCPeerConnection(this.configuration);\r\n        this.peerConnections.set(participantId, peerConnection);\r\n\r\n        // Add local stream tracks\r\n        if (this.localStream) {\r\n            this.localStream.getTracks().forEach(track => {\r\n                peerConnection.addTrack(track, this.localStream);\r\n            });\r\n        }\r\n\r\n        // Handle incoming stream\r\n        peerConnection.ontrack = (event) => {\r\n            console.log('Received remote track from:', participantId);\r\n            if (this.onRemoteStream) {\r\n                this.onRemoteStream(participantId, event.streams[0]);\r\n            }\r\n        };\r\n\r\n        // Handle ICE candidates\r\n        peerConnection.onicecandidate = (event) => {\r\n            if (event.candidate) {\r\n                this.sendSignalingMessage({\r\n                    type: 'ice-candidate',\r\n                    candidate: event.candidate,\r\n                    from: this.currentUserId,\r\n                    to: participantId\r\n                });\r\n            }\r\n        };\r\n\r\n        // Handle connection state changes\r\n        peerConnection.onconnectionstatechange = () => {\r\n            console.log(`Connection state with ${participantId}:`, peerConnection.connectionState);\r\n            if (peerConnection.connectionState === 'disconnected' ||\r\n                peerConnection.connectionState === 'failed') {\r\n                this.closePeerConnection(participantId);\r\n            }\r\n        };\r\n\r\n        return peerConnection;\r\n    }\r\n\r\n    async createOffer(participantId) {\r\n        const peerConnection = await this.createPeerConnection(participantId);\r\n        const offer = await peerConnection.createOffer();\r\n        await peerConnection.setLocalDescription(offer);\r\n\r\n        this.sendSignalingMessage({\r\n            type: 'offer',\r\n            offer: offer,\r\n            from: this.currentUserId,\r\n            to: participantId\r\n        });\r\n    }\r\n\r\n    async handleSignalingMessage(message) {\r\n        const { type, from, to, offer, answer, candidate } = message;\r\n\r\n        // Ignore messages not meant for us\r\n        if (to && to !== this.currentUserId) {\r\n            return;\r\n        }\r\n\r\n        // Don't process our own messages\r\n        if (from === this.currentUserId) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            switch (type) {\r\n                case 'offer':\r\n                    await this.handleOffer(from, offer);\r\n                    break;\r\n                case 'answer':\r\n                    await this.handleAnswer(from, answer);\r\n                    break;\r\n                case 'ice-candidate':\r\n                    await this.handleIceCandidate(from, candidate);\r\n                    break;\r\n                case 'participant-left':\r\n                    this.handleParticipantLeft(from);\r\n                    break;\r\n                default:\r\n                    console.log('Unknown signaling message type:', type);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error handling signaling message:', error);\r\n        }\r\n    }\r\n\r\n    async handleOffer(participantId, offer) {\r\n        const peerConnection = await this.createPeerConnection(participantId);\r\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\r\n\r\n        const answer = await peerConnection.createAnswer();\r\n        await peerConnection.setLocalDescription(answer);\r\n\r\n        this.sendSignalingMessage({\r\n            type: 'answer',\r\n            answer: answer,\r\n            from: this.currentUserId,\r\n            to: participantId\r\n        });\r\n    }\r\n\r\n    async handleAnswer(participantId, answer) {\r\n        const peerConnection = this.peerConnections.get(participantId);\r\n        if (peerConnection) {\r\n            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\r\n        }\r\n    }\r\n\r\n    async handleIceCandidate(participantId, candidate) {\r\n        const peerConnection = this.peerConnections.get(participantId);\r\n        if (peerConnection) {\r\n            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\r\n        }\r\n    }\r\n\r\n    handleParticipantLeft(participantId) {\r\n        this.closePeerConnection(participantId);\r\n        if (this.onParticipantLeft) {\r\n            this.onParticipantLeft(participantId);\r\n        }\r\n    }\r\n\r\n    sendSignalingMessage(message) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            this.stompClient.publish({\r\n                destination: `/app/signal/${this.roomCode}`,\r\n                body: JSON.stringify(message)\r\n            });\r\n        }\r\n    }\r\n\r\n    notifyJoin() {\r\n        this.sendSignalingMessage({\r\n            type: 'join',\r\n            from: this.currentUserId\r\n        });\r\n    }\r\n\r\n    notifyLeave() {\r\n        this.sendSignalingMessage({\r\n            type: 'participant-left',\r\n            from: this.currentUserId\r\n        });\r\n    }\r\n\r\n    updateLocalStream(newStream) {\r\n        this.localStream = newStream;\r\n\r\n        // Update all peer connections with new tracks\r\n        this.peerConnections.forEach((peerConnection, participantId) => {\r\n            const senders = peerConnection.getSenders();\r\n            const newTracks = newStream.getTracks();\r\n\r\n            senders.forEach(sender => {\r\n                const newTrack = newTracks.find(track => track.kind === sender.track?.kind);\r\n                if (newTrack) {\r\n                    sender.replaceTrack(newTrack);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    toggleTrack(kind, enabled) {\r\n        if (this.localStream) {\r\n            const tracks = kind === 'video'\r\n                ? this.localStream.getVideoTracks()\r\n                : this.localStream.getAudioTracks();\r\n\r\n            tracks.forEach(track => {\r\n                track.enabled = enabled;\r\n            });\r\n        }\r\n    }\r\n\r\n    closePeerConnection(participantId) {\r\n        const peerConnection = this.peerConnections.get(participantId);\r\n        if (peerConnection) {\r\n            peerConnection.close();\r\n            this.peerConnections.delete(participantId);\r\n        }\r\n    }\r\n\r\n    cleanup() {\r\n        this.notifyLeave();\r\n\r\n        this.peerConnections.forEach((pc, id) => {\r\n            pc.close();\r\n        });\r\n        this.peerConnections.clear();\r\n\r\n        if (this.localStream) {\r\n            this.localStream.getTracks().forEach(track => track.stop());\r\n            this.localStream = null;\r\n        }\r\n\r\n        this.stompClient = null;\r\n        this.roomCode = null;\r\n        this.currentUserId = null;\r\n    }\r\n}\r\n\r\nexport default new WebRTCService();"],"mappings":"AAAA,MAAMA,aAAa,CAAC;EAChBC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IAChC,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,iBAAiB,GAAG,IAAI;IAE7B,IAAI,CAACC,aAAa,GAAG;MACjBC,UAAU,EAAE,CACR;QAAEC,IAAI,EAAE;MAA+B,CAAC,EACxC;QAAEA,IAAI,EAAE;MAAgC,CAAC,EACzC;QAAEA,IAAI,EAAE;MAAgC,CAAC;IAEjD,CAAC;EACL;EAEAC,UAAUA,CAACR,WAAW,EAAEC,QAAQ,EAAEQ,MAAM,EAAEV,WAAW,EAAE;IACnD,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,aAAa,GAAGO,MAAM;IAC3B,IAAI,CAACV,WAAW,GAAGA,WAAW;;IAE9B;IACA,IAAI,CAACC,WAAW,CAACU,SAAS,CAAC,iBAAiBT,QAAQ,EAAE,EAAGU,OAAO,IAAK;MACjE,IAAI,CAACC,sBAAsB,CAACC,IAAI,CAACC,KAAK,CAACH,OAAO,CAACI,IAAI,CAAC,CAAC;IACzD,CAAC,CAAC;EACN;EAEA,MAAMC,oBAAoBA,CAACC,aAAa,EAAE;IACtC,IAAI,IAAI,CAACpB,eAAe,CAACqB,GAAG,CAACD,aAAa,CAAC,EAAE;MACzC,OAAO,IAAI,CAACpB,eAAe,CAACsB,GAAG,CAACF,aAAa,CAAC;IAClD;IAEA,MAAMG,cAAc,GAAG,IAAIC,iBAAiB,CAAC,IAAI,CAAChB,aAAa,CAAC;IAChE,IAAI,CAACR,eAAe,CAACyB,GAAG,CAACL,aAAa,EAAEG,cAAc,CAAC;;IAEvD;IACA,IAAI,IAAI,CAACrB,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACwB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAI;QAC1CL,cAAc,CAACM,QAAQ,CAACD,KAAK,EAAE,IAAI,CAAC1B,WAAW,CAAC;MACpD,CAAC,CAAC;IACN;;IAEA;IACAqB,cAAc,CAACO,OAAO,GAAIC,KAAK,IAAK;MAChCC,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEb,aAAa,CAAC;MACzD,IAAI,IAAI,CAACd,cAAc,EAAE;QACrB,IAAI,CAACA,cAAc,CAACc,aAAa,EAAEW,KAAK,CAACG,OAAO,CAAC,CAAC,CAAC,CAAC;MACxD;IACJ,CAAC;;IAED;IACAX,cAAc,CAACY,cAAc,GAAIJ,KAAK,IAAK;MACvC,IAAIA,KAAK,CAACK,SAAS,EAAE;QACjB,IAAI,CAACC,oBAAoB,CAAC;UACtBC,IAAI,EAAE,eAAe;UACrBF,SAAS,EAAEL,KAAK,CAACK,SAAS;UAC1BG,IAAI,EAAE,IAAI,CAAClC,aAAa;UACxBmC,EAAE,EAAEpB;QACR,CAAC,CAAC;MACN;IACJ,CAAC;;IAED;IACAG,cAAc,CAACkB,uBAAuB,GAAG,MAAM;MAC3CT,OAAO,CAACC,GAAG,CAAC,yBAAyBb,aAAa,GAAG,EAAEG,cAAc,CAACmB,eAAe,CAAC;MACtF,IAAInB,cAAc,CAACmB,eAAe,KAAK,cAAc,IACjDnB,cAAc,CAACmB,eAAe,KAAK,QAAQ,EAAE;QAC7C,IAAI,CAACC,mBAAmB,CAACvB,aAAa,CAAC;MAC3C;IACJ,CAAC;IAED,OAAOG,cAAc;EACzB;EAEA,MAAMqB,WAAWA,CAACxB,aAAa,EAAE;IAC7B,MAAMG,cAAc,GAAG,MAAM,IAAI,CAACJ,oBAAoB,CAACC,aAAa,CAAC;IACrE,MAAMyB,KAAK,GAAG,MAAMtB,cAAc,CAACqB,WAAW,CAAC,CAAC;IAChD,MAAMrB,cAAc,CAACuB,mBAAmB,CAACD,KAAK,CAAC;IAE/C,IAAI,CAACR,oBAAoB,CAAC;MACtBC,IAAI,EAAE,OAAO;MACbO,KAAK,EAAEA,KAAK;MACZN,IAAI,EAAE,IAAI,CAAClC,aAAa;MACxBmC,EAAE,EAAEpB;IACR,CAAC,CAAC;EACN;EAEA,MAAML,sBAAsBA,CAACD,OAAO,EAAE;IAClC,MAAM;MAAEwB,IAAI;MAAEC,IAAI;MAAEC,EAAE;MAAEK,KAAK;MAAEE,MAAM;MAAEX;IAAU,CAAC,GAAGtB,OAAO;;IAE5D;IACA,IAAI0B,EAAE,IAAIA,EAAE,KAAK,IAAI,CAACnC,aAAa,EAAE;MACjC;IACJ;;IAEA;IACA,IAAIkC,IAAI,KAAK,IAAI,CAAClC,aAAa,EAAE;MAC7B;IACJ;IAEA,IAAI;MACA,QAAQiC,IAAI;QACR,KAAK,OAAO;UACR,MAAM,IAAI,CAACU,WAAW,CAACT,IAAI,EAAEM,KAAK,CAAC;UACnC;QACJ,KAAK,QAAQ;UACT,MAAM,IAAI,CAACI,YAAY,CAACV,IAAI,EAAEQ,MAAM,CAAC;UACrC;QACJ,KAAK,eAAe;UAChB,MAAM,IAAI,CAACG,kBAAkB,CAACX,IAAI,EAAEH,SAAS,CAAC;UAC9C;QACJ,KAAK,kBAAkB;UACnB,IAAI,CAACe,qBAAqB,CAACZ,IAAI,CAAC;UAChC;QACJ;UACIP,OAAO,CAACC,GAAG,CAAC,iCAAiC,EAAEK,IAAI,CAAC;MAC5D;IACJ,CAAC,CAAC,OAAOc,KAAK,EAAE;MACZpB,OAAO,CAACoB,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;IAC7D;EACJ;EAEA,MAAMJ,WAAWA,CAAC5B,aAAa,EAAEyB,KAAK,EAAE;IACpC,MAAMtB,cAAc,GAAG,MAAM,IAAI,CAACJ,oBAAoB,CAACC,aAAa,CAAC;IACrE,MAAMG,cAAc,CAAC8B,oBAAoB,CAAC,IAAIC,qBAAqB,CAACT,KAAK,CAAC,CAAC;IAE3E,MAAME,MAAM,GAAG,MAAMxB,cAAc,CAACgC,YAAY,CAAC,CAAC;IAClD,MAAMhC,cAAc,CAACuB,mBAAmB,CAACC,MAAM,CAAC;IAEhD,IAAI,CAACV,oBAAoB,CAAC;MACtBC,IAAI,EAAE,QAAQ;MACdS,MAAM,EAAEA,MAAM;MACdR,IAAI,EAAE,IAAI,CAAClC,aAAa;MACxBmC,EAAE,EAAEpB;IACR,CAAC,CAAC;EACN;EAEA,MAAM6B,YAAYA,CAAC7B,aAAa,EAAE2B,MAAM,EAAE;IACtC,MAAMxB,cAAc,GAAG,IAAI,CAACvB,eAAe,CAACsB,GAAG,CAACF,aAAa,CAAC;IAC9D,IAAIG,cAAc,EAAE;MAChB,MAAMA,cAAc,CAAC8B,oBAAoB,CAAC,IAAIC,qBAAqB,CAACP,MAAM,CAAC,CAAC;IAChF;EACJ;EAEA,MAAMG,kBAAkBA,CAAC9B,aAAa,EAAEgB,SAAS,EAAE;IAC/C,MAAMb,cAAc,GAAG,IAAI,CAACvB,eAAe,CAACsB,GAAG,CAACF,aAAa,CAAC;IAC9D,IAAIG,cAAc,EAAE;MAChB,MAAMA,cAAc,CAACiC,eAAe,CAAC,IAAIC,eAAe,CAACrB,SAAS,CAAC,CAAC;IACxE;EACJ;EAEAe,qBAAqBA,CAAC/B,aAAa,EAAE;IACjC,IAAI,CAACuB,mBAAmB,CAACvB,aAAa,CAAC;IACvC,IAAI,IAAI,CAACb,iBAAiB,EAAE;MACxB,IAAI,CAACA,iBAAiB,CAACa,aAAa,CAAC;IACzC;EACJ;EAEAiB,oBAAoBA,CAACvB,OAAO,EAAE;IAC1B,IAAI,IAAI,CAACX,WAAW,IAAI,IAAI,CAACA,WAAW,CAACuD,SAAS,EAAE;MAChD,IAAI,CAACvD,WAAW,CAACwD,OAAO,CAAC;QACrBC,WAAW,EAAE,eAAe,IAAI,CAACxD,QAAQ,EAAE;QAC3Cc,IAAI,EAAEF,IAAI,CAAC6C,SAAS,CAAC/C,OAAO;MAChC,CAAC,CAAC;IACN;EACJ;EAEAgD,UAAUA,CAAA,EAAG;IACT,IAAI,CAACzB,oBAAoB,CAAC;MACtBC,IAAI,EAAE,MAAM;MACZC,IAAI,EAAE,IAAI,CAAClC;IACf,CAAC,CAAC;EACN;EAEA0D,WAAWA,CAAA,EAAG;IACV,IAAI,CAAC1B,oBAAoB,CAAC;MACtBC,IAAI,EAAE,kBAAkB;MACxBC,IAAI,EAAE,IAAI,CAAClC;IACf,CAAC,CAAC;EACN;EAEA2D,iBAAiBA,CAACC,SAAS,EAAE;IACzB,IAAI,CAAC/D,WAAW,GAAG+D,SAAS;;IAE5B;IACA,IAAI,CAACjE,eAAe,CAAC2B,OAAO,CAAC,CAACJ,cAAc,EAAEH,aAAa,KAAK;MAC5D,MAAM8C,OAAO,GAAG3C,cAAc,CAAC4C,UAAU,CAAC,CAAC;MAC3C,MAAMC,SAAS,GAAGH,SAAS,CAACvC,SAAS,CAAC,CAAC;MAEvCwC,OAAO,CAACvC,OAAO,CAAC0C,MAAM,IAAI;QACtB,MAAMC,QAAQ,GAAGF,SAAS,CAACG,IAAI,CAAC3C,KAAK;UAAA,IAAA4C,aAAA;UAAA,OAAI5C,KAAK,CAAC6C,IAAI,OAAAD,aAAA,GAAKH,MAAM,CAACzC,KAAK,cAAA4C,aAAA,uBAAZA,aAAA,CAAcC,IAAI;QAAA,EAAC;QAC3E,IAAIH,QAAQ,EAAE;UACVD,MAAM,CAACK,YAAY,CAACJ,QAAQ,CAAC;QACjC;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEAK,WAAWA,CAACF,IAAI,EAAEG,OAAO,EAAE;IACvB,IAAI,IAAI,CAAC1E,WAAW,EAAE;MAClB,MAAM2E,MAAM,GAAGJ,IAAI,KAAK,OAAO,GACzB,IAAI,CAACvE,WAAW,CAAC4E,cAAc,CAAC,CAAC,GACjC,IAAI,CAAC5E,WAAW,CAAC6E,cAAc,CAAC,CAAC;MAEvCF,MAAM,CAAClD,OAAO,CAACC,KAAK,IAAI;QACpBA,KAAK,CAACgD,OAAO,GAAGA,OAAO;MAC3B,CAAC,CAAC;IACN;EACJ;EAEAjC,mBAAmBA,CAACvB,aAAa,EAAE;IAC/B,MAAMG,cAAc,GAAG,IAAI,CAACvB,eAAe,CAACsB,GAAG,CAACF,aAAa,CAAC;IAC9D,IAAIG,cAAc,EAAE;MAChBA,cAAc,CAACyD,KAAK,CAAC,CAAC;MACtB,IAAI,CAAChF,eAAe,CAACiF,MAAM,CAAC7D,aAAa,CAAC;IAC9C;EACJ;EAEA8D,OAAOA,CAAA,EAAG;IACN,IAAI,CAACnB,WAAW,CAAC,CAAC;IAElB,IAAI,CAAC/D,eAAe,CAAC2B,OAAO,CAAC,CAACwD,EAAE,EAAEC,EAAE,KAAK;MACrCD,EAAE,CAACH,KAAK,CAAC,CAAC;IACd,CAAC,CAAC;IACF,IAAI,CAAChF,eAAe,CAACqF,KAAK,CAAC,CAAC;IAE5B,IAAI,IAAI,CAACnF,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACwB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAAC0D,IAAI,CAAC,CAAC,CAAC;MAC3D,IAAI,CAACpF,WAAW,GAAG,IAAI;IAC3B;IAEA,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,aAAa,GAAG,IAAI;EAC7B;AACJ;AAEA,eAAe,IAAIP,aAAa,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}