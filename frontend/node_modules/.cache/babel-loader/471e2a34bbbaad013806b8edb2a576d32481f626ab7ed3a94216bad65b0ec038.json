{"ast":null,"code":"class WebRTCService {\n  constructor() {\n    this.peerConnections = new Map();\n    this.localStream = null;\n    this.stompClient = null;\n    this.roomCode = null;\n    this.currentUserId = null;\n    this.onRemoteStream = null;\n    this.onParticipantLeft = null;\n    this.pendingCandidates = new Map();\n    this.existingParticipants = new Set();\n    this.initiatedConnections = new Set();\n    this.subscriptions = []; // Track subscriptions for cleanup\n    this.configuration = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }]\n    };\n  }\n  initialize(stompClient, roomCode, userId, localStream) {\n    this.stompClient = stompClient;\n    this.roomCode = roomCode;\n    this.currentUserId = String(userId);\n    this.localStream = localStream;\n    console.log('[WebRTC] üîß INITIALIZING:');\n    console.log('  - User ID:', this.currentUserId);\n    console.log('  - Room Code:', roomCode);\n    console.log('  - Subscribing to room topic:', `/topic/signal/${roomCode}`);\n    console.log('  - Subscribing to personal topic:', `/topic/signal/${roomCode}/${this.currentUserId}`);\n\n    // Room-wide subscription\n    const roomSub = this.stompClient.subscribe(`/topic/signal/${roomCode}`, message => {\n      console.log('[WebRTC] üì® ROOM MESSAGE:', message.body);\n      this.handleSignalingMessage(JSON.parse(message.body));\n    });\n    this.subscriptions.push(roomSub);\n\n    // Personal subscription\n    const personalSub = this.stompClient.subscribe(`/topic/signal/${roomCode}/${this.currentUserId}`, message => {\n      console.log('[WebRTC] üì¨ PERSONAL MESSAGE:', message.body);\n      this.handleSignalingMessage(JSON.parse(message.body));\n    });\n    this.subscriptions.push(personalSub);\n    console.log('[WebRTC] ‚úÖ Both subscriptions created successfully');\n  }\n  async createPeerConnection(participantId) {\n    const participantIdStr = String(participantId);\n    if (this.peerConnections.has(participantIdStr)) {\n      console.log('[WebRTC] Reusing existing peer connection with:', participantIdStr);\n      return this.peerConnections.get(participantIdStr);\n    }\n    console.log('[WebRTC] Creating NEW peer connection with:', participantIdStr);\n    const peerConnection = new RTCPeerConnection(this.configuration);\n    this.peerConnections.set(participantIdStr, peerConnection);\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        console.log('[WebRTC] Adding local track to PC:', track.kind, 'enabled:', track.enabled);\n        peerConnection.addTrack(track, this.localStream);\n      });\n    }\n    peerConnection.ontrack = event => {\n      console.log('[WebRTC] üé• RECEIVED REMOTE TRACK from:', participantIdStr, 'kind:', event.track.kind);\n      console.log('[WebRTC] Track details - readyState:', event.track.readyState, 'enabled:', event.track.enabled);\n      console.log('[WebRTC] Streams received:', event.streams.length);\n      if (event.streams && event.streams[0]) {\n        const stream = event.streams[0];\n        console.log('[WebRTC] Stream tracks:', stream.getTracks().map(t => t.kind));\n        if (this.onRemoteStream) {\n          console.log('[WebRTC] ‚úÖ Calling onRemoteStream callback for:', participantIdStr);\n          this.onRemoteStream(participantIdStr, stream);\n        } else {\n          console.error('[WebRTC] ‚ùå onRemoteStream callback is NULL!');\n        }\n      } else {\n        console.error('[WebRTC] ‚ùå No stream in track event!');\n      }\n    };\n    peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        console.log('[WebRTC] Sending ICE candidate to:', participantIdStr);\n        this.sendSignalingMessage({\n          type: 'ice-candidate',\n          candidate: event.candidate,\n          from: this.currentUserId,\n          to: participantIdStr\n        });\n      }\n    };\n    peerConnection.onconnectionstatechange = () => {\n      console.log('[WebRTC] Connection state with', participantIdStr + ':', peerConnection.connectionState);\n      if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {\n        this.closePeerConnection(participantIdStr);\n      }\n    };\n    peerConnection.oniceconnectionstatechange = () => {\n      console.log('[WebRTC] ICE state with', participantIdStr + ':', peerConnection.iceConnectionState);\n    };\n    return peerConnection;\n  }\n  async createOffer(participantId) {\n    const participantIdStr = String(participantId);\n    try {\n      console.log('[WebRTC] üì§ Creating offer for:', participantIdStr);\n      const peerConnection = await this.createPeerConnection(participantIdStr);\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n      await peerConnection.setLocalDescription(offer);\n      console.log('[WebRTC] Offer created and set as local description');\n      this.sendSignalingMessage({\n        type: 'offer',\n        offer: offer,\n        from: this.currentUserId,\n        to: participantIdStr\n      });\n      this.initiatedConnections.add(participantIdStr);\n    } catch (error) {\n      console.error('[WebRTC] ‚ùå Error creating offer:', error);\n    }\n  }\n  async handleSignalingMessage(message) {\n    const {\n      type,\n      from,\n      to\n    } = message;\n    const fromStr = String(from);\n    const toStr = to ? String(to) : null;\n\n    // Ignore messages from self\n    if (fromStr === this.currentUserId) {\n      console.log('[WebRTC] üîÑ Ignoring message from self:', type);\n      return;\n    }\n\n    // For targeted messages, check if it's for me\n    if (toStr && toStr !== this.currentUserId) {\n      console.log('[WebRTC] üö´ Message not for me, ignoring. From:', fromStr, 'To:', toStr);\n      return;\n    }\n    console.log('[WebRTC] üì® Processing signaling:', type, 'from:', fromStr, 'to:', toStr || 'broadcast');\n    try {\n      switch (type) {\n        case 'join':\n          console.log('[WebRTC] üéØ Handling join from:', fromStr);\n          await this.handleJoin(fromStr);\n          break;\n        case 'offer':\n          console.log('[WebRTC] üì• Handling offer from:', fromStr);\n          await this.handleOffer(fromStr, message.offer);\n          break;\n        case 'answer':\n          console.log('[WebRTC] üì• Handling answer from:', fromStr);\n          await this.handleAnswer(fromStr, message.answer);\n          break;\n        case 'ice-candidate':\n          console.log('[WebRTC] üßä Handling ICE candidate from:', fromStr);\n          await this.handleIceCandidate(fromStr, message.candidate);\n          break;\n        case 'leave':\n        case 'participant-left':\n          console.log('[WebRTC] üëã Participant left:', fromStr);\n          this.handleParticipantLeft(fromStr);\n          break;\n        default:\n          console.warn('[WebRTC] ‚ö†Ô∏è Unknown message type:', type);\n      }\n    } catch (error) {\n      console.error('[WebRTC] ‚ùå Error handling signaling message:', error, 'Message:', message);\n    }\n  }\n  async handleJoin(participantId) {\n    const participantIdStr = String(participantId);\n    console.log('[WebRTC] üëã PARTICIPANT JOINED - Processing:', participantIdStr, 'Current user:', this.currentUserId);\n    if (participantIdStr === this.currentUserId) {\n      console.log('[WebRTC] üîÑ Ignoring own join message');\n      return;\n    }\n    if (this.existingParticipants.has(participantIdStr)) {\n      console.log('[WebRTC] ‚ö†Ô∏è Participant already exists:', participantIdStr);\n      return;\n    }\n    this.existingParticipants.add(participantIdStr);\n    console.log('[WebRTC] ‚úÖ Added to existing participants:', participantIdStr);\n    try {\n      await this.createPeerConnection(participantIdStr);\n      console.log('[WebRTC] ‚úÖ Peer connection created for:', participantIdStr);\n    } catch (error) {\n      console.error('[WebRTC] ‚ùå Failed to create peer connection for:', participantIdStr, error);\n      return;\n    }\n    const shouldInitiate = this.shouldInitiateConnection(this.currentUserId, participantIdStr);\n    console.log('[WebRTC] ü§î Should I initiate connection?', shouldInitiate, 'My ID:', this.currentUserId, 'Their ID:', participantIdStr);\n    if (shouldInitiate) {\n      console.log('[WebRTC] üéØ I will create offer to:', participantIdStr);\n      setTimeout(async () => {\n        try {\n          console.log('[WebRTC] üöÄ Creating offer to:', participantIdStr);\n          await this.createOffer(participantIdStr);\n        } catch (error) {\n          console.error('[WebRTC] ‚ùå Failed to create offer to:', participantIdStr, error);\n        }\n      }, 1500);\n    } else {\n      console.log('[WebRTC] ‚è≥ Waiting for offer from:', participantIdStr);\n    }\n  }\n  shouldInitiateConnection(userId1, userId2) {\n    const id1 = String(userId1);\n    const id2 = String(userId2);\n    const shouldInitiate = id1 < id2;\n    console.log('[WebRTC] üéØ Connection initiation check:', id1, '<', id2, '=', shouldInitiate);\n    return shouldInitiate;\n  }\n  async handleOffer(participantId, offer) {\n    try {\n      const participantIdStr = String(participantId);\n      console.log('[WebRTC] üì• Handling offer from:', participantIdStr);\n      this.existingParticipants.add(participantIdStr);\n      if (this.peerConnections.has(participantIdStr)) {\n        console.log('[WebRTC] ‚ö†Ô∏è Already have connection, closing old one');\n        this.closePeerConnection(participantIdStr);\n      }\n      const peerConnection = await this.createPeerConnection(participantIdStr);\n      console.log('[WebRTC] üîß Setting remote description from offer');\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n      console.log('[WebRTC] ‚úÖ Remote description set from offer');\n      if (this.pendingCandidates.has(participantIdStr)) {\n        const candidates = this.pendingCandidates.get(participantIdStr);\n        console.log('[WebRTC] üîå Adding', candidates.length, 'pending candidates');\n        for (const candidate of candidates) {\n          try {\n            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n          } catch (e) {\n            console.error('[WebRTC] ‚ùå Error adding pending candidate:', e);\n          }\n        }\n        this.pendingCandidates.delete(participantIdStr);\n      }\n      console.log('[WebRTC] üì§ Creating answer');\n      const answer = await peerConnection.createAnswer();\n      await peerConnection.setLocalDescription(answer);\n      console.log('[WebRTC] ‚úÖ Answer created and set as local description');\n      this.sendSignalingMessage({\n        type: 'answer',\n        answer: answer,\n        from: this.currentUserId,\n        to: participantIdStr\n      });\n      console.log('[WebRTC] üì® Answer sent to:', participantIdStr);\n    } catch (error) {\n      console.error('[WebRTC] ‚ùå Error handling offer:', error);\n    }\n  }\n  async handleAnswer(participantId, answer) {\n    try {\n      const participantIdStr = String(participantId);\n      console.log('[WebRTC] üì• Handling answer from:', participantIdStr);\n      const peerConnection = this.peerConnections.get(participantIdStr);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n        console.log('[WebRTC] ‚úÖ Remote description set from answer');\n        if (this.pendingCandidates.has(participantIdStr)) {\n          const candidates = this.pendingCandidates.get(participantIdStr);\n          console.log('[WebRTC] üîå Adding', candidates.length, 'pending candidates');\n          for (const candidate of candidates) {\n            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n          }\n          this.pendingCandidates.delete(participantIdStr);\n        }\n      } else {\n        console.error('[WebRTC] ‚ùå No peer connection found for:', participantIdStr);\n      }\n    } catch (error) {\n      console.error('[WebRTC] ‚ùå Error handling answer:', error);\n    }\n  }\n  async handleIceCandidate(participantId, candidate) {\n    try {\n      const participantIdStr = String(participantId);\n      const peerConnection = this.peerConnections.get(participantIdStr);\n      if (peerConnection && peerConnection.remoteDescription) {\n        console.log('[WebRTC] üîå Adding ICE candidate from:', participantIdStr);\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n      } else {\n        console.log('[WebRTC] üíæ Storing pending ICE candidate from:', participantIdStr);\n        if (!this.pendingCandidates.has(participantIdStr)) {\n          this.pendingCandidates.set(participantIdStr, []);\n        }\n        this.pendingCandidates.get(participantIdStr).push(candidate);\n      }\n    } catch (error) {\n      console.error('[WebRTC] ‚ùå Error handling ICE candidate:', error);\n    }\n  }\n  handleParticipantLeft(participantId) {\n    const participantIdStr = String(participantId);\n    console.log('[WebRTC] üëã Participant left:', participantIdStr);\n    this.closePeerConnection(participantIdStr);\n    this.pendingCandidates.delete(participantIdStr);\n    this.existingParticipants.delete(participantIdStr);\n    this.initiatedConnections.delete(participantIdStr);\n    if (this.onParticipantLeft) {\n      this.onParticipantLeft(participantIdStr);\n    }\n  }\n  sendSignalingMessage(message) {\n    if (this.stompClient && this.stompClient.connected) {\n      console.log('[WebRTC] üì§ Sending signaling message:', message.type, 'to:', message.to || 'room');\n      this.stompClient.publish({\n        destination: `/app/signal/${this.roomCode}`,\n        body: JSON.stringify(message)\n      });\n    } else {\n      console.error('[WebRTC] ‚ùå Cannot send signaling message: STOMP client not connected');\n    }\n  }\n  notifyJoin() {\n    console.log('[WebRTC] üì£ Notifying join to room:', this.roomCode, 'as user:', this.currentUserId);\n    if (this.stompClient && this.roomCode) {\n      const joinMessage = {\n        type: 'join',\n        from: this.currentUserId,\n        roomCode: this.roomCode,\n        timestamp: new Date().toISOString()\n      };\n      this.stompClient.publish({\n        destination: `/app/signal/${this.roomCode}`,\n        body: JSON.stringify(joinMessage)\n      });\n      console.log('[WebRTC] ‚úÖ Join notification sent');\n    } else {\n      console.error('[WebRTC] ‚ùå Cannot notify join - missing stompClient or roomCode');\n    }\n  }\n  notifyLeave() {\n    console.log('[WebRTC] üì¢ Notifying leave for user:', this.currentUserId);\n    this.sendSignalingMessage({\n      type: 'leave',\n      from: this.currentUserId\n    });\n  }\n  updateLocalStream(newStream) {\n    this.localStream = newStream;\n    this.peerConnections.forEach((peerConnection, participantId) => {\n      const senders = peerConnection.getSenders();\n      const newTracks = newStream.getTracks();\n      senders.forEach(sender => {\n        const newTrack = newTracks.find(track => {\n          var _sender$track;\n          return track.kind === ((_sender$track = sender.track) === null || _sender$track === void 0 ? void 0 : _sender$track.kind);\n        });\n        if (newTrack) {\n          sender.replaceTrack(newTrack);\n        }\n      });\n    });\n  }\n  toggleTrack(kind, enabled) {\n    if (this.localStream) {\n      const tracks = kind === 'video' ? this.localStream.getVideoTracks() : this.localStream.getAudioTracks();\n      tracks.forEach(track => {\n        track.enabled = enabled;\n        console.log(`[WebRTC] ${kind} track ${enabled ? 'enabled' : 'disabled'}`);\n      });\n    }\n  }\n  closePeerConnection(participantId) {\n    const participantIdStr = String(participantId);\n    const peerConnection = this.peerConnections.get(participantIdStr);\n    if (peerConnection) {\n      peerConnection.close();\n      this.peerConnections.delete(participantIdStr);\n      console.log('[WebRTC] ‚ùå Closed peer connection with:', participantIdStr);\n    }\n  }\n  cleanup() {\n    console.log('[WebRTC] üßπ Cleaning up WebRTC service');\n    this.notifyLeave();\n    this.subscriptions.forEach(sub => {\n      try {\n        sub.unsubscribe();\n      } catch (e) {\n        console.error('[WebRTC] Error unsubscribing:', e);\n      }\n    });\n    this.subscriptions = [];\n    this.peerConnections.forEach((pc, id) => {\n      pc.close();\n    });\n    this.peerConnections.clear();\n    this.pendingCandidates.clear();\n    this.existingParticipants.clear();\n    this.initiatedConnections.clear();\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n    this.stompClient = null;\n    this.roomCode = null;\n    this.currentUserId = null;\n  }\n}\nexport default new WebRTCService();","map":{"version":3,"names":["WebRTCService","constructor","peerConnections","Map","localStream","stompClient","roomCode","currentUserId","onRemoteStream","onParticipantLeft","pendingCandidates","existingParticipants","Set","initiatedConnections","subscriptions","configuration","iceServers","urls","initialize","userId","String","console","log","roomSub","subscribe","message","body","handleSignalingMessage","JSON","parse","push","personalSub","createPeerConnection","participantId","participantIdStr","has","get","peerConnection","RTCPeerConnection","set","getTracks","forEach","track","kind","enabled","addTrack","ontrack","event","readyState","streams","length","stream","map","t","error","onicecandidate","candidate","sendSignalingMessage","type","from","to","onconnectionstatechange","connectionState","closePeerConnection","oniceconnectionstatechange","iceConnectionState","createOffer","offer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","add","fromStr","toStr","handleJoin","handleOffer","handleAnswer","answer","handleIceCandidate","handleParticipantLeft","warn","shouldInitiate","shouldInitiateConnection","setTimeout","userId1","userId2","id1","id2","setRemoteDescription","RTCSessionDescription","candidates","addIceCandidate","RTCIceCandidate","e","delete","createAnswer","remoteDescription","connected","publish","destination","stringify","notifyJoin","joinMessage","timestamp","Date","toISOString","notifyLeave","updateLocalStream","newStream","senders","getSenders","newTracks","sender","newTrack","find","_sender$track","replaceTrack","toggleTrack","tracks","getVideoTracks","getAudioTracks","close","cleanup","sub","unsubscribe","pc","id","clear","stop"],"sources":["E:/fliora/fliora/frontend/src/services/WebRTCService.js"],"sourcesContent":["class WebRTCService {\r\n    constructor() {\r\n        this.peerConnections = new Map();\r\n        this.localStream = null;\r\n        this.stompClient = null;\r\n        this.roomCode = null;\r\n        this.currentUserId = null;\r\n        this.onRemoteStream = null;\r\n        this.onParticipantLeft = null;\r\n        this.pendingCandidates = new Map();\r\n        this.existingParticipants = new Set();\r\n        this.initiatedConnections = new Set();\r\n        this.subscriptions = []; // Track subscriptions for cleanup\r\n        this.configuration = {\r\n            iceServers: [\r\n                { urls: 'stun:stun.l.google.com:19302' },\r\n                { urls: 'stun:stun1.l.google.com:19302' },\r\n                { urls: 'stun:stun2.l.google.com:19302' }\r\n            ]\r\n        };\r\n    }\r\n\r\n    initialize(stompClient, roomCode, userId, localStream) {\r\n        this.stompClient = stompClient;\r\n        this.roomCode = roomCode;\r\n        this.currentUserId = String(userId);\r\n        this.localStream = localStream;\r\n\r\n        console.log('[WebRTC] üîß INITIALIZING:');\r\n        console.log('  - User ID:', this.currentUserId);\r\n        console.log('  - Room Code:', roomCode);\r\n        console.log('  - Subscribing to room topic:', `/topic/signal/${roomCode}`);\r\n        console.log('  - Subscribing to personal topic:', `/topic/signal/${roomCode}/${this.currentUserId}`);\r\n\r\n        // Room-wide subscription\r\n        const roomSub = this.stompClient.subscribe(`/topic/signal/${roomCode}`, (message) => {\r\n            console.log('[WebRTC] üì® ROOM MESSAGE:', message.body);\r\n            this.handleSignalingMessage(JSON.parse(message.body));\r\n        });\r\n        this.subscriptions.push(roomSub);\r\n\r\n        // Personal subscription\r\n        const personalSub = this.stompClient.subscribe(`/topic/signal/${roomCode}/${this.currentUserId}`, (message) => {\r\n            console.log('[WebRTC] üì¨ PERSONAL MESSAGE:', message.body);\r\n            this.handleSignalingMessage(JSON.parse(message.body));\r\n        });\r\n        this.subscriptions.push(personalSub);\r\n\r\n        console.log('[WebRTC] ‚úÖ Both subscriptions created successfully');\r\n    }\r\n\r\n    async createPeerConnection(participantId) {\r\n        const participantIdStr = String(participantId);\r\n\r\n        if (this.peerConnections.has(participantIdStr)) {\r\n            console.log('[WebRTC] Reusing existing peer connection with:', participantIdStr);\r\n            return this.peerConnections.get(participantIdStr);\r\n        }\r\n\r\n        console.log('[WebRTC] Creating NEW peer connection with:', participantIdStr);\r\n        const peerConnection = new RTCPeerConnection(this.configuration);\r\n        this.peerConnections.set(participantIdStr, peerConnection);\r\n\r\n        if (this.localStream) {\r\n            this.localStream.getTracks().forEach(track => {\r\n                console.log('[WebRTC] Adding local track to PC:', track.kind, 'enabled:', track.enabled);\r\n                peerConnection.addTrack(track, this.localStream);\r\n            });\r\n        }\r\n\r\n        peerConnection.ontrack = (event) => {\r\n            console.log('[WebRTC] üé• RECEIVED REMOTE TRACK from:', participantIdStr, 'kind:', event.track.kind);\r\n            console.log('[WebRTC] Track details - readyState:', event.track.readyState, 'enabled:', event.track.enabled);\r\n            console.log('[WebRTC] Streams received:', event.streams.length);\r\n\r\n            if (event.streams && event.streams[0]) {\r\n                const stream = event.streams[0];\r\n                console.log('[WebRTC] Stream tracks:', stream.getTracks().map(t => t.kind));\r\n\r\n                if (this.onRemoteStream) {\r\n                    console.log('[WebRTC] ‚úÖ Calling onRemoteStream callback for:', participantIdStr);\r\n                    this.onRemoteStream(participantIdStr, stream);\r\n                } else {\r\n                    console.error('[WebRTC] ‚ùå onRemoteStream callback is NULL!');\r\n                }\r\n            } else {\r\n                console.error('[WebRTC] ‚ùå No stream in track event!');\r\n            }\r\n        };\r\n\r\n        peerConnection.onicecandidate = (event) => {\r\n            if (event.candidate) {\r\n                console.log('[WebRTC] Sending ICE candidate to:', participantIdStr);\r\n                this.sendSignalingMessage({\r\n                    type: 'ice-candidate',\r\n                    candidate: event.candidate,\r\n                    from: this.currentUserId,\r\n                    to: participantIdStr\r\n                });\r\n            }\r\n        };\r\n\r\n        peerConnection.onconnectionstatechange = () => {\r\n            console.log('[WebRTC] Connection state with', participantIdStr + ':', peerConnection.connectionState);\r\n            if (peerConnection.connectionState === 'disconnected' ||\r\n                peerConnection.connectionState === 'failed') {\r\n                this.closePeerConnection(participantIdStr);\r\n            }\r\n        };\r\n\r\n        peerConnection.oniceconnectionstatechange = () => {\r\n            console.log('[WebRTC] ICE state with', participantIdStr + ':', peerConnection.iceConnectionState);\r\n        };\r\n\r\n        return peerConnection;\r\n    }\r\n\r\n    async createOffer(participantId) {\r\n        const participantIdStr = String(participantId);\r\n\r\n        try {\r\n            console.log('[WebRTC] üì§ Creating offer for:', participantIdStr);\r\n            const peerConnection = await this.createPeerConnection(participantIdStr);\r\n\r\n            const offer = await peerConnection.createOffer({\r\n                offerToReceiveAudio: true,\r\n                offerToReceiveVideo: true\r\n            });\r\n\r\n            await peerConnection.setLocalDescription(offer);\r\n            console.log('[WebRTC] Offer created and set as local description');\r\n\r\n            this.sendSignalingMessage({\r\n                type: 'offer',\r\n                offer: offer,\r\n                from: this.currentUserId,\r\n                to: participantIdStr\r\n            });\r\n\r\n            this.initiatedConnections.add(participantIdStr);\r\n        } catch (error) {\r\n            console.error('[WebRTC] ‚ùå Error creating offer:', error);\r\n        }\r\n    }\r\n\r\n    async handleSignalingMessage(message) {\r\n        const { type, from, to } = message;\r\n        const fromStr = String(from);\r\n        const toStr = to ? String(to) : null;\r\n\r\n        // Ignore messages from self\r\n        if (fromStr === this.currentUserId) {\r\n            console.log('[WebRTC] üîÑ Ignoring message from self:', type);\r\n            return;\r\n        }\r\n\r\n        // For targeted messages, check if it's for me\r\n        if (toStr && toStr !== this.currentUserId) {\r\n            console.log('[WebRTC] üö´ Message not for me, ignoring. From:', fromStr, 'To:', toStr);\r\n            return;\r\n        }\r\n\r\n        console.log('[WebRTC] üì® Processing signaling:', type, 'from:', fromStr, 'to:', toStr || 'broadcast');\r\n\r\n        try {\r\n            switch (type) {\r\n                case 'join':\r\n                    console.log('[WebRTC] üéØ Handling join from:', fromStr);\r\n                    await this.handleJoin(fromStr);\r\n                    break;\r\n                case 'offer':\r\n                    console.log('[WebRTC] üì• Handling offer from:', fromStr);\r\n                    await this.handleOffer(fromStr, message.offer);\r\n                    break;\r\n                case 'answer':\r\n                    console.log('[WebRTC] üì• Handling answer from:', fromStr);\r\n                    await this.handleAnswer(fromStr, message.answer);\r\n                    break;\r\n                case 'ice-candidate':\r\n                    console.log('[WebRTC] üßä Handling ICE candidate from:', fromStr);\r\n                    await this.handleIceCandidate(fromStr, message.candidate);\r\n                    break;\r\n                case 'leave':\r\n                case 'participant-left':\r\n                    console.log('[WebRTC] üëã Participant left:', fromStr);\r\n                    this.handleParticipantLeft(fromStr);\r\n                    break;\r\n                default:\r\n                    console.warn('[WebRTC] ‚ö†Ô∏è Unknown message type:', type);\r\n            }\r\n        } catch (error) {\r\n            console.error('[WebRTC] ‚ùå Error handling signaling message:', error, 'Message:', message);\r\n        }\r\n    }\r\n\r\n    async handleJoin(participantId) {\r\n        const participantIdStr = String(participantId);\r\n        console.log('[WebRTC] üëã PARTICIPANT JOINED - Processing:', participantIdStr, 'Current user:', this.currentUserId);\r\n\r\n        if (participantIdStr === this.currentUserId) {\r\n            console.log('[WebRTC] üîÑ Ignoring own join message');\r\n            return;\r\n        }\r\n\r\n        if (this.existingParticipants.has(participantIdStr)) {\r\n            console.log('[WebRTC] ‚ö†Ô∏è Participant already exists:', participantIdStr);\r\n            return;\r\n        }\r\n\r\n        this.existingParticipants.add(participantIdStr);\r\n        console.log('[WebRTC] ‚úÖ Added to existing participants:', participantIdStr);\r\n\r\n        try {\r\n            await this.createPeerConnection(participantIdStr);\r\n            console.log('[WebRTC] ‚úÖ Peer connection created for:', participantIdStr);\r\n        } catch (error) {\r\n            console.error('[WebRTC] ‚ùå Failed to create peer connection for:', participantIdStr, error);\r\n            return;\r\n        }\r\n\r\n        const shouldInitiate = this.shouldInitiateConnection(this.currentUserId, participantIdStr);\r\n        console.log('[WebRTC] ü§î Should I initiate connection?', shouldInitiate,\r\n            'My ID:', this.currentUserId, 'Their ID:', participantIdStr);\r\n\r\n        if (shouldInitiate) {\r\n            console.log('[WebRTC] üéØ I will create offer to:', participantIdStr);\r\n            setTimeout(async () => {\r\n                try {\r\n                    console.log('[WebRTC] üöÄ Creating offer to:', participantIdStr);\r\n                    await this.createOffer(participantIdStr);\r\n                } catch (error) {\r\n                    console.error('[WebRTC] ‚ùå Failed to create offer to:', participantIdStr, error);\r\n                }\r\n            }, 1500);\r\n        } else {\r\n            console.log('[WebRTC] ‚è≥ Waiting for offer from:', participantIdStr);\r\n        }\r\n    }\r\n\r\n    shouldInitiateConnection(userId1, userId2) {\r\n        const id1 = String(userId1);\r\n        const id2 = String(userId2);\r\n        const shouldInitiate = id1 < id2;\r\n        console.log('[WebRTC] üéØ Connection initiation check:', id1, '<', id2, '=', shouldInitiate);\r\n        return shouldInitiate;\r\n    }\r\n\r\n    async handleOffer(participantId, offer) {\r\n        try {\r\n            const participantIdStr = String(participantId);\r\n            console.log('[WebRTC] üì• Handling offer from:', participantIdStr);\r\n\r\n            this.existingParticipants.add(participantIdStr);\r\n\r\n            if (this.peerConnections.has(participantIdStr)) {\r\n                console.log('[WebRTC] ‚ö†Ô∏è Already have connection, closing old one');\r\n                this.closePeerConnection(participantIdStr);\r\n            }\r\n\r\n            const peerConnection = await this.createPeerConnection(participantIdStr);\r\n\r\n            console.log('[WebRTC] üîß Setting remote description from offer');\r\n            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\r\n            console.log('[WebRTC] ‚úÖ Remote description set from offer');\r\n\r\n            if (this.pendingCandidates.has(participantIdStr)) {\r\n                const candidates = this.pendingCandidates.get(participantIdStr);\r\n                console.log('[WebRTC] üîå Adding', candidates.length, 'pending candidates');\r\n                for (const candidate of candidates) {\r\n                    try {\r\n                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\r\n                    } catch (e) {\r\n                        console.error('[WebRTC] ‚ùå Error adding pending candidate:', e);\r\n                    }\r\n                }\r\n                this.pendingCandidates.delete(participantIdStr);\r\n            }\r\n\r\n            console.log('[WebRTC] üì§ Creating answer');\r\n            const answer = await peerConnection.createAnswer();\r\n            await peerConnection.setLocalDescription(answer);\r\n            console.log('[WebRTC] ‚úÖ Answer created and set as local description');\r\n\r\n            this.sendSignalingMessage({\r\n                type: 'answer',\r\n                answer: answer,\r\n                from: this.currentUserId,\r\n                to: participantIdStr\r\n            });\r\n\r\n            console.log('[WebRTC] üì® Answer sent to:', participantIdStr);\r\n        } catch (error) {\r\n            console.error('[WebRTC] ‚ùå Error handling offer:', error);\r\n        }\r\n    }\r\n\r\n    async handleAnswer(participantId, answer) {\r\n        try {\r\n            const participantIdStr = String(participantId);\r\n            console.log('[WebRTC] üì• Handling answer from:', participantIdStr);\r\n            const peerConnection = this.peerConnections.get(participantIdStr);\r\n\r\n            if (peerConnection) {\r\n                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\r\n                console.log('[WebRTC] ‚úÖ Remote description set from answer');\r\n\r\n                if (this.pendingCandidates.has(participantIdStr)) {\r\n                    const candidates = this.pendingCandidates.get(participantIdStr);\r\n                    console.log('[WebRTC] üîå Adding', candidates.length, 'pending candidates');\r\n                    for (const candidate of candidates) {\r\n                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\r\n                    }\r\n                    this.pendingCandidates.delete(participantIdStr);\r\n                }\r\n            } else {\r\n                console.error('[WebRTC] ‚ùå No peer connection found for:', participantIdStr);\r\n            }\r\n        } catch (error) {\r\n            console.error('[WebRTC] ‚ùå Error handling answer:', error);\r\n        }\r\n    }\r\n\r\n    async handleIceCandidate(participantId, candidate) {\r\n        try {\r\n            const participantIdStr = String(participantId);\r\n            const peerConnection = this.peerConnections.get(participantIdStr);\r\n\r\n            if (peerConnection && peerConnection.remoteDescription) {\r\n                console.log('[WebRTC] üîå Adding ICE candidate from:', participantIdStr);\r\n                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\r\n            } else {\r\n                console.log('[WebRTC] üíæ Storing pending ICE candidate from:', participantIdStr);\r\n                if (!this.pendingCandidates.has(participantIdStr)) {\r\n                    this.pendingCandidates.set(participantIdStr, []);\r\n                }\r\n                this.pendingCandidates.get(participantIdStr).push(candidate);\r\n            }\r\n        } catch (error) {\r\n            console.error('[WebRTC] ‚ùå Error handling ICE candidate:', error);\r\n        }\r\n    }\r\n\r\n    handleParticipantLeft(participantId) {\r\n        const participantIdStr = String(participantId);\r\n        console.log('[WebRTC] üëã Participant left:', participantIdStr);\r\n        this.closePeerConnection(participantIdStr);\r\n        this.pendingCandidates.delete(participantIdStr);\r\n        this.existingParticipants.delete(participantIdStr);\r\n        this.initiatedConnections.delete(participantIdStr);\r\n        if (this.onParticipantLeft) {\r\n            this.onParticipantLeft(participantIdStr);\r\n        }\r\n    }\r\n\r\n    sendSignalingMessage(message) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            console.log('[WebRTC] üì§ Sending signaling message:', message.type, 'to:', message.to || 'room');\r\n            this.stompClient.publish({\r\n                destination: `/app/signal/${this.roomCode}`,\r\n                body: JSON.stringify(message)\r\n            });\r\n        } else {\r\n            console.error('[WebRTC] ‚ùå Cannot send signaling message: STOMP client not connected');\r\n        }\r\n    }\r\n\r\n    notifyJoin() {\r\n        console.log('[WebRTC] üì£ Notifying join to room:', this.roomCode, 'as user:', this.currentUserId);\r\n\r\n        if (this.stompClient && this.roomCode) {\r\n            const joinMessage = {\r\n                type: 'join',\r\n                from: this.currentUserId,\r\n                roomCode: this.roomCode,\r\n                timestamp: new Date().toISOString()\r\n            };\r\n\r\n            this.stompClient.publish({\r\n                destination: `/app/signal/${this.roomCode}`,\r\n                body: JSON.stringify(joinMessage)\r\n            });\r\n            console.log('[WebRTC] ‚úÖ Join notification sent');\r\n        } else {\r\n            console.error('[WebRTC] ‚ùå Cannot notify join - missing stompClient or roomCode');\r\n        }\r\n    }\r\n\r\n    notifyLeave() {\r\n        console.log('[WebRTC] üì¢ Notifying leave for user:', this.currentUserId);\r\n        this.sendSignalingMessage({\r\n            type: 'leave',\r\n            from: this.currentUserId\r\n        });\r\n    }\r\n\r\n    updateLocalStream(newStream) {\r\n        this.localStream = newStream;\r\n\r\n        this.peerConnections.forEach((peerConnection, participantId) => {\r\n            const senders = peerConnection.getSenders();\r\n            const newTracks = newStream.getTracks();\r\n\r\n            senders.forEach(sender => {\r\n                const newTrack = newTracks.find(track => track.kind === sender.track?.kind);\r\n                if (newTrack) {\r\n                    sender.replaceTrack(newTrack);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    toggleTrack(kind, enabled) {\r\n        if (this.localStream) {\r\n            const tracks = kind === 'video'\r\n                ? this.localStream.getVideoTracks()\r\n                : this.localStream.getAudioTracks();\r\n\r\n            tracks.forEach(track => {\r\n                track.enabled = enabled;\r\n                console.log(`[WebRTC] ${kind} track ${enabled ? 'enabled' : 'disabled'}`);\r\n            });\r\n        }\r\n    }\r\n\r\n    closePeerConnection(participantId) {\r\n        const participantIdStr = String(participantId);\r\n        const peerConnection = this.peerConnections.get(participantIdStr);\r\n        if (peerConnection) {\r\n            peerConnection.close();\r\n            this.peerConnections.delete(participantIdStr);\r\n            console.log('[WebRTC] ‚ùå Closed peer connection with:', participantIdStr);\r\n        }\r\n    }\r\n\r\n    cleanup() {\r\n        console.log('[WebRTC] üßπ Cleaning up WebRTC service');\r\n        this.notifyLeave();\r\n        this.subscriptions.forEach(sub => {\r\n            try {\r\n                sub.unsubscribe();\r\n            } catch (e) {\r\n                console.error('[WebRTC] Error unsubscribing:', e);\r\n            }\r\n        });\r\n        this.subscriptions = [];\r\n\r\n        this.peerConnections.forEach((pc, id) => {\r\n            pc.close();\r\n        });\r\n        this.peerConnections.clear();\r\n        this.pendingCandidates.clear();\r\n        this.existingParticipants.clear();\r\n        this.initiatedConnections.clear();\r\n\r\n        if (this.localStream) {\r\n            this.localStream.getTracks().forEach(track => track.stop());\r\n            this.localStream = null;\r\n        }\r\n\r\n        this.stompClient = null;\r\n        this.roomCode = null;\r\n        this.currentUserId = null;\r\n    }\r\n}\r\n\r\nexport default new WebRTCService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}